import GameConfig
import Collections
import Utils
import kernel.Math

internal native OnUpdateUnitEntity(integer id, integer player, UnitType unitType, real hp, real maxHP, real mp, real maxMP)
internal native OnRemoveUnitEntity(integer id)
internal native OnUnitBuffChanged(integer unitId, integer buffId, bool addition)

public delegate real UnitDamageEvent(Unit source, real damage, Unit target)//返回修正后的伤害值
public UnitDamageEventList AnyUnitTakesDamage = UnitDamageEventList()
public class UnitDamageEventList
    private List list = List()
    public Add(UnitDamageEvent event)
        list.Add(event)
    public Remove(UnitDamageEvent event)
        list.RemoveFirst(item => UnitDamageEvent & item == event)
    public real Invoke(Unit source, real damage, Unit target)
        for var i = 0; i < list.Count(); i++
            damage = (UnitDamageEvent & list.Get(i))(source, damage, target)
        return damage

public delegate UnitDeathEvent(Unit killer, Unit dead)
public UnitDeathEventList AnyUnitDeath = UnitDeathEventList()
public class UnitDeathEventList
    private List list = List()
    public Add(UnitDeathEvent event)
        list.Add(event)
    public Remove(UnitDeathEvent event)
        list.RemoveFirst(item => UnitDeathEvent & item == event)
    public Invoke(Unit killer, Unit dead)
        list.Foreach(item => (UnitDeathEvent & item)(killer, dead))
public DamageUnit(Unit source, real damage, Unit target)
    if target == null || !target.valid
        return
    damage = AnyUnitTakesDamage.Invoke(source, damage, target)
    target.Hit(source, damage)
    
public const string UNIT_ANIM_IDLE = "idle"
public const string UNIT_ANIM_MOVE = "move"
public const string UNIT_ANIM_DEATH = "death"
public delegate real HitEvent(Unit source, real damage)//返回修正后的伤害值
public class HitEventList
    private List list = List()
    public Add(HitEvent e)
        list.Add(e)
    public Remove(HitEvent e)
        list.RemoveFirst(item => HitEvent & item == e)
    public real Invoke(Unit source, real damage)
        for var i = 0; i < list.Count(); i++
            damage = (HitEvent & list.Get(i))(source, damage)
        return damage
        
public class Unit GameEntity
    public bool valid = true
    public Player player
    public integer configId
    public UnitType unitType
    private real hp
    private real maxHP
    private real mp
    private real maxMP
    public real moveSpeed
    private bool autoMoving
    public real3 targetPosition
    public List buffs = List()//<Buff>
    public HitEventList onHitEvent = HitEventList()
    private real2 pressure
    private bool dirty = false
    public Unit(integer configId, Player player, real3 forward, real3 position)
        var config = GetUnitConfig(configId)
        base.Init(config.entityConfigId, "stand", forward, position)
        this.player = player
        this.configId = configId
        unitType = config.unitType
        hp = maxHP = config.hp
        mp = maxMP = config.mp
        moveSpeed = config.speed
        this->OnUpdate()
        autoMoving = false
        start MainLoop()
    public Remove(bool immediately)
        if !valid
            return
        for var i = 0; i < buffs.Count(); i++
            var buff = Buff & buffs.Get(i)
            OnUnitBuffChanged(GetHandleID(), buff.GetHandleID(), false)
            buff.Remove()
        OnRemoveUnitEntity(GetHandleID())
        ShowAnim(UNIT_ANIM_DEATH)
        base.Remove(immediately)
        valid = false

    private MainLoop()
        while valid
            UpdateAutoMove()
            if dirty
                this->OnUpdate()
                dirty = false
            wait

    public AddBuff(integer buffId, Unit source)
        if !valid
            return
        var cfg = GetBuffConfig(buffId)
        if cfg.refresh || cfg.accumulation
            for var i = 0; i < buffs.Count(); i++
                var b = Buff& buffs.Get(i)
                if b.config.id == buffId
                    b.OnUpdate(source)
                    return
        var buff = CreateBuff(cfg, source, this)
        buffs.Add(buff)
        OnUnitBuffChanged(GetHandleID(), buff.GetHandleID(), true)
    public Remove(Buff buff)
        if !valid
            return
        OnUnitBuffChanged(GetHandleID(), buff.GetHandleID(), false)
        buffs.Remove(buff)
        buff.Remove()
    public real Hit(Unit source, real damage)//返回真正造成的伤害
        damage = onHitEvent.Invoke(source, damage)
        SetHP(hp - damage)
        if hp == 0
            AnyUnitDeath.Invoke(source, this)
            Remove(false)
        return damage
    public Goto(real3 target)
        if !valid
            return
        targetPosition = target
        if autoMoving
            return
        autoMoving = true
        ShowAnim(UNIT_ANIM_MOVE)
    public RockMove(real dir, real dis)//dir[-π,π] dis[0,1]
        if !valid
            return
        autoMoving = false
        ShowAnim(UNIT_ANIM_MOVE)
        var forward = DirToForward(dir)
        var delta = moveSpeed * LOGIC_TIMESTEP * dis * forward
        Move(forward, position + delta)
    public StopMove()
        if !valid
            return
        autoMoving = false
        ShowAnim(UNIT_ANIM_IDLE)
    private OnSelectEntity(GameEntity e)
        if e != this and e is Unit u
            pressure += position.xz - u.position.xz
    private UpdateAutoMove()
        pressure = real2()
        worldRoot.SelectRange(position.xz, 1, OnSelectEntity)
        var dir = pressure.Normalized() * Clamp01(pressure.SqrMagnitude())// * moveSpeed
        if autoMoving
            var forward = targetPosition - position
            StepMove(forward + real3(dir.x, 0, dir.y))
        elseif dir.SqrMagnitude() > 0
            StepMove(real3(dir.x, 0, dir.y))
    private StepMove(real3 forward)
        var target = position + forward
        var sqrDis = forward.SqrMagnitude()
        forward = forward.Normalized()
        var step = moveSpeed * LOGIC_TIMESTEP
        if sqrDis < step * step
            Move(forward, target)
            ShowAnim(UNIT_ANIM_IDLE)
            autoMoving = false
        else
            Move(forward, position + forward * step)
    public real, real, real, real GetStates()//hp,maxHP,mp,maxMP
        return hp, maxHP, mp, maxMP
    public real GetHP()
        return hp
    public real GetMaxHP()
        return maxHP
    public real GetMP()
        return mp
    public real GetMaxMP()
        return maxMP
    public SetHP(real hp)
        hp = Clamp(hp, 0, maxHP)
        if hp != this.hp
            dirty = true
        this.hp = hp
    public SetHP(real hp, real maxHP)
        if maxHP != this.maxHP
            dirty = true
        this.maxHP = maxHP
        SetHP(hp)
    public SetMP(real mp)
        mp = Clamp(mp, 0, maxHP)
        if mp != this.mp
            dirty = true
        this.mp = mp
    public SetMP(real mp, real maxMP)
        if maxMP < this.maxMP
            dirty = true
        this.maxMP = maxMP
        SetMP(mp)
    private OnUpdate()
        OnUpdateUnitEntity(GetHandleID(), player.id, unitType, hp, maxHP, mp, maxMP)