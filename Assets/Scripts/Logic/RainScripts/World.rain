
import kernel.Math
import GameConfig

public Area worldRoot = GetLeafArea(null, real2(0, 0), WORLD_SIZE)

public delegate OnSelectEntity(GameEntity)
public delegate bool TerminalCondition()
public class Area
    public Area parent
    public real2 position
    public real size    //区域正方形边长的一半
    public integer count
    // 1 │ 0
    //───┼───
    // 2 │ 3
    public Area[] subAreas = Area[4]
    public GameEntity[] entities = GameEntity[4]
    public bool Contains(real2 position)
        if parent == null
            return true
        return position.x > this.position.x - size && position.x <= this.position.x + size && position.y > this.position.y - size && position.y <= this.position.y + size
    private bool Overlaps(real2 position, real radius)
        position -= this.position
        if Abs(position.x) < size + radius && Abs(position.y) < size + radius
            if Abs(position.x) > size && Abs(position.y) > size
                position -= real2(Sign(position.x), Sign(position.y)) * size
                return position.SqrMagnitude() < radius * radius
            return true
        return false

    private Area GetSubArea(real2 position)
        if position.x > this.position.x
            if position.y > this.position.y
                return subAreas[0]
            return subAreas[3]
        elseif position.y > this.position.y
            return subAreas[1]
        return subAreas[2]

    private Split()
        var subSize = size * .5
        subAreas[0] = GetLeafArea(this, real2(subSize, subSize) + position, subSize)
        subAreas[1] = GetLeafArea(this, real2(-subSize, subSize) + position, subSize)
        subAreas[2] = GetLeafArea(this, real2(-subSize, -subSize) + position, subSize)
        subAreas[3] = GetLeafArea(this, real2(subSize, -subSize) + position, subSize)
        for var i = 0; i < count; i++
            var e = entities[i]
            GetSubArea(e.position.xz).Add(e)
        entities = null
    private Gather()
        entities = GameEntity[count]
        count = 0
        for var areaIdx, var subAreaCnt = 0, subAreas.GetLength(); areaIdx < subAreaCnt; areaIdx++
            var area = subAreas[areaIdx]
            for var i, var cnt = 0, area.count; i < cnt; i++
                entities[count++] = area.entities[i]
                area.entities[i].area = this
            Recycle(area)
            subAreas[areaIdx] = null

    public Add(GameEntity value)
        if entities != null
            if size > LOWER_LIMIT_AREA_SIZE && count >= UPPER_LIMIT_AREA_ENTITY_COUNT
                Split()
            else
                entities, count = global Add(entities, count, value)
                value.area = this
                return
        GetSubArea(value.position.xz)->Add(value)
        count++

    private OnRemove()
        count--
        if count < LOWER_LIMIT_AREA_ENTITY_COUNT
            Gather()
        parent?->OnRemove()
    public Remove(GameEntity value)
        if entities != null
            entities, count = RemoveSwap(entities, count, value)
            parent?->OnRemove()
    public SelectRange(real2 position, real radius, OnSelectEntity onSelect)
        SelectRange(position, radius, onSelect, null)
    public bool SelectRange(real2 position, real radius, OnSelectEntity onSelect, TerminalCondition condition)
        if Overlaps(position, radius)
            if entities != null
                var sqrRadius = radius * radius
                for var i = 0; i < count; i++
                    var e = entities[i]
                    var d = e.position.xz - position
                    if d.SqrMagnitude() < sqrRadius
                        onSelect(e)
                        if condition?()
                            return true
            elseif subAreas[0]->SelectRange(position, radius, onSelect, condition)
                return true
            elseif subAreas[1]->SelectRange(position, radius, onSelect, condition)
                return true
            elseif subAreas[2]->SelectRange(position, radius, onSelect, condition)
                return true
            elseif subAreas[3]->SelectRange(position, radius, onSelect, condition)
                return true
        return false
    public SelectAll(OnSelectEntity onSelect)
        SelectAll(onSelect, null)
    public bool SelectAll(OnSelectEntity onSelect, TerminalCondition condition)
        if entities != null
            for var i = 0; i < count; i++
                onSelect(entities[i])
                if condition?()
                    return true
        elseif subAreas[0]->SelectAll(onSelect, condition)
            return true
        elseif subAreas[1]->SelectAll(onSelect, condition)
            return true
        elseif subAreas[2]->SelectAll(onSelect, condition)
            return true
        elseif subAreas[3]->SelectAll(onSelect, condition)
            return true
        return false
    public Move(GameEntity value, real2 position)
        this->Remove(value)
        value.position.xz = position
        worldRoot->Add(value)

    public ShowDebugLine()
        var p00 = real3(position.x - size, 0, position.y - size)
        var p01 = real3(position.x - size, 0, position.y + size)
        var p11 = real3(position.x + size, 0, position.y + size)
        var p10 = real3(position.x + size, 0, position.y - size)
        DrwaLine(p00, p01)
        DrwaLine(p01, p11) 
        DrwaLine(p11, p10) 
        DrwaLine(p10, p00)
        if entities == null
            subAreas[0].ShowDebugLine()
            subAreas[1].ShowDebugLine()
            subAreas[2].ShowDebugLine()
            subAreas[3].ShowDebugLine()
internal DebugWorld()
    ClearLines()
    worldRoot.ShowDebugLine()

public Area[] areaPool = Area[16]
public integer areaPoolCount = 0
public Area GetLeafArea(Area parent, real2 position, real size)
    var result = areaPoolCount > 0 ? areaPool[--areaPoolCount] : Area()
    result.parent = parent
    result.position = position
    result.size = size
    result.entities = GameEntity[4]
    result.count = 0
    return result
public Recycle(Area area)
    if areaPool.GetLength() == areaPoolCount
        var nap = Area[areaPoolCount * 2]
        for var i = 0; i < areaPoolCount; i++
            nap[i] = areaPool[i]
        areaPool = nap
    areaPool[areaPoolCount++] = area

public real GetRandomRange(real min, real max)
    return min + GetRandomReal() * (max - min)
public real3 GetRandomWorldPosition()
    return real3(GetRandomRange( -WORLD_SIZE, WORLD_SIZE), 0, GetRandomRange( -WORLD_SIZE, WORLD_SIZE)) / 100
            
public real gameTime = 0
public StartWorld()
    while
        wait
        gameTime += LOGIC_TIMESTEP
        DebugWorld()

public Wait(real second)
    wait integer& (second / LOGIC_TIMESTEP)

